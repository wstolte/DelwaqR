ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
library(shiny)
library(miniUI)
library(ggplot2)
ggbrush <- function(data, xvar, yvar) {
ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
runGadget(ui, server)
library(shiny)
library(miniUI)
library(ggplot2)
install.packages(miniUI)
install.packages("miniUI")
install.packages("miniUI")
library(shiny)
library(miniUI)
library(ggplot2)
ggbrush <- function(data, xvar, yvar) {
ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
ggbrush
ggbrush()
ggbrush(mtcars, "hp", "mpg")
ggbrush(mtcars, "hp", "mpg")
x <- c(as = "asfef", qu = "qwerty", "yuiop[", "b", "stuff.blah.yech")
# split x on the letter e
strsplit(x, "e")
strReverse <- function(x)
sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
strReverse(c("abc", "Statistics"))
installed.packages("splitstackshape")
require(splitstackshape)
install.packages(c("curl", "devtools", "ggmap", "httr", "knitr", "maptools", "memoise", "mvtnorm", "ncdf4", "nlme", "R6", "RcppEigen", "RNeo4j", "rstudioapi", "TH.data", "tidyr"))
install.packages("mgcv", lib="D:/stolte/Documents/R/R-3.2.2/library")
install.packages("splitstackshape")
require(splitstackshape)
temp <- head(concat.test)
## Split the "Likes" column
cSplit(temp, "Likes")
temp <- head(concat.test)
View(temp)
cSplit(temp, "Likes")
cSplit(temp, c("Likes", "Hates"), c(",", ";"))
cSplit(temp, "Siblings", ",", direction = "long")
## Split "Siblings" into a long form, removing extra whitespace
cSplit(temp, "Siblings", ",", direction = "long", stripWhite = TRUE)
## Split a vector
y <- c("a_b_c", "a_b", "c_a_b")
cSplit(as.data.table(y), "y", "_")
y
require(stringr)
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
plot +
geom_line(aes(), size = 1) +
geom_point(aes(), fill = "white",  shape = 21, size = 4) +
facet_grid((variable ~ location)) +
theme_bw() +
theme(text = element_text(size = 14),
axis.text.x = element_text(angle=90, vjust=0.5))
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
dimnames(arr)
install.packages("stingi")
install.packages("stringi")
install.packages("stringi")
require(stringi)
stri_split_fixed("a_b_c_d", "_")
stri_split_fixed("a_b_c__d", "_")
stri_split_fixed("a_b_c__d", "_", omit_empty=TRUE)
stri_split_fixed("a_b_c__d", "_", n=2, tokens_only=FALSE) # "a" & remainder
stri_split_fixed("a_b_c__d", "_", n=2, tokens_only=TRUE) # "a" & "b" only
stri_split_fixed("a_b_c__d", "_", n=4, omit_empty=TRUE, tokens_only=TRUE)
stri_split_fixed("a_b_c__d", "_", n=4, omit_empty=FALSE, tokens_only=TRUE)
stri_split_fixed("a_b_c__d", "_", omit_empty=NA)
stri_split_fixed(c("ab_c", "d_ef_g", "h", ""), "_", n=1, tokens_only=TRUE, omit_empty=TRUE)
stri_split_fixed(c("ab_c", "d_ef_g", "h", ""), "_", n=2, tokens_only=TRUE, omit_empty=TRUE)
stri_split_fixed(c("ab_c", "d_ef_g", "h", ""), "_", n=3, tokens_only=TRUE, omit_empty=TRUE)
stri_list2matrix(stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=TRUE))
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=FALSE, simplify=TRUE)
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=NA, simplify=TRUE)
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=TRUE, simplify=TRUE)
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=NA, simplify=NA)
test <- "The\u00a0above-mentioned features are very useful. " %s+%
"Warm thanks to their developers. 123 456 789"
stri_split_boundaries(test, type="line")
stri_split_boundaries(test, type="word")
stri_split_boundaries(test, type="word", skip_word_none=TRUE)
stri_split_boundaries(test, type="word", skip_word_none=TRUE, skip_word_letter=TRUE)
stri_split_boundaries(test, type="word", skip_word_none=TRUE, skip_word_number=TRUE)
stri_split_boundaries(test, type="sentence")
stri_split_boundaries(test, type="sentence", skip_sentence_sep=TRUE)
stri_split_boundaries(test, type="sentence")
stri_split_boundaries(test, type="character")
stri_startswith_charclass(" trim me! ", "\\p{WSpace}")
stri_startswith_fixed(c("a1", "a2", "b3", "a4", "c5"), "a")
stri_detect_regex(c("a1", "a2", "b3", "a4", "c5"), "^a")
stri_startswith_fixed("ababa", "ba")
stri_startswith_fixed("ababa", "ba", from=2)
stri_startswith_coll(c("a1", "A2", "b3", "A4", "C5"), "a", strength=1)
pat <- stri_paste("\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 ",
"\u0639\u0644\u064a\u0647 \u0648\u0633\u0644\u0645XYZ")
stri_endswith_coll("\ufdfa\ufdfa\ufdfaXYZ", pat, strength=1)
stri_trim_left(" aaa")
stri_trim_right("rexamine.com/", "\\p{P}")
stri_trim_both(" Total of 23.5 bitcoins. ", "\\p{N}")
stri_trim_both(" Total of 23.5 bitcoins. ", "\\p{L}")
stri_trim_both(" Total of 23.5 bitcoins. ", "\\p{N}")
stri_trim_both("NO301", "\\p{N}")
stri_replace_all_charclass("aaaa", "[a]", "b", merge=c(TRUE, FALSE))
stri_replace_all_charclass("aaaa", "[a]", "b", merge=c(TRUE, FALSE))
stri_replace_all_charclass("a\nb\tc d", "\\p{WHITE_SPACE}", " ")
stri_replace_all_charclass("a\nb\tc d", "\\p{WHITE_SPACE}", " ", merge=TRUE)
s <- "Lorem ipsum dolor sit amet, consectetur adipisicing elit."
stri_replace_all_fixed(s, " ", "#")
stri_replace_all_fixed(s, "o", "0")
stri_replace_all_regex(s, " .*? ", "#")
stri_replace_all_regex('123|456|789', '(\\p{N}).(\\p{N})', '$2-$1')
df$variable
stri_replace_all_regex(s, "(el|s)it", "1234")
stri_replace_all_regex('123|456|789', '(\\p{N}).(\\p{N})', '$2-$1')
grep("[a-z]", letters)
"[a-z]"
grep("[a-z]")
letters
grep("[a-z]", letters)
txt <- c("arm","foot","lefroo", "bafoobar")
if(length(i <- grep("foo", txt)))
cat("'foo' appears at least once in\n\t", txt, "\n")
i # 2 and 4
txt[i]
## Double all 'a' or 'b's;  "\" must be escaped, i.e., 'doubled'
gsub("([ab])", "\\1_\\1_", "abc and ABC")
txt <- c("The", "licenses", "for", "most", "software", "are",
"designed", "to", "take", "away", "your", "freedom",
"to", "share", "and", "change", "it.",
"", "By", "contrast,", "the", "GNU", "General", "Public", "License",
"is", "intended", "to", "guarantee", "your", "freedom", "to",
"share", "and", "change", "free", "software", "--",
"to", "make", "sure", "the", "software", "is",
"free", "for", "all", "its", "users")
( i <- grep("[gu]", txt) ) # indices
stopifnot( txt[i] == grep("[gu]", txt, value = TRUE) )
(ot <- sub("[b-e]",".", txt))
txt[ot != gsub("[b-e]",".", txt)]#- gsub does "global" substitution
txt[gsub("g","#", txt) !=
gsub("g","#", txt, ignore.case = TRUE)] # the "G" words
regexpr("en", txt)
gregexpr("e", txt)
## Using grepl() for filtering
## Find functions with argument names matching "warn":
findArgs <- function(env, pattern) {
nms <- ls(envir = as.environment(env))
nms <- nms[is.na(match(nms, c("F","T")))] # <-- work around "checking hack"
aa <- sapply(nms, function(.) { o <- get(.)
if(is.function(o)) names(formals(o)) })
iw <- sapply(aa, function(a) any(grepl(pattern, a, ignore.case=TRUE)))
aa[iw]
}
findArgs("package:base", "warn")
str <- "Now is the time      "
sub(" +$", "", str)  ## spaces only
## what is considered 'white space' depends on the locale.
sub("[[:space:]]+$", "", str) ## white space, POSIX-style
## what PCRE considered white space changed in version 8.34: see ?regex
sub("\\s+$", "", str, perl = TRUE) ## PCRE-style white space
## capitalizing
txt <- "a test of capitalizing"
gsub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)
gsub("\\b(\\w)",    "\\U\\1",       txt, perl=TRUE)
txt2 <- "useRs may fly into JFK or laGuardia"
gsub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
sub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
## named capture
notables <- c("  Ben Franklin and Jefferson Davis",
"\tMillard Fillmore")
# name groups 'first' and 'last'
name.rex <- "(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)"
(parsed <- regexpr(name.rex, notables, perl = TRUE))
gregexpr(name.rex, notables, perl = TRUE)[[2]]
parse.one <- function(res, result) {
m <- do.call(rbind, lapply(seq_along(res), function(i) {
if(result[i] == -1) return("")
st <- attr(result, "capture.start")[i, ]
substring(res[i], st, st + attr(result, "capture.length")[i, ] - 1)
}))
colnames(m) <- attr(result, "capture.names")
m
}
parse.one(notables, parsed)
## Decompose a URL into its components.
## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
x <- "http://stat.umn.edu:80/xyz"
m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
m
regmatches(x, m)
## Element 3 is the protocol, 4 is the host, 6 is the port, and 7
## is the path.  We can use this to make a function for extracting the
## parts of a URL:
URL_parts <- function(x) {
m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
parts <- do.call(rbind,
lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)))
colnames(parts) <- c("protocol","host","port","path")
parts
}
URL_parts(x)
## There is no gregexec() yet, but one can emulate it by running
## regexec() on the regmatches obtained via gregexpr().  E.g.:
pattern <- "([[:alpha:]]+)([[:digit:]]+)"
s <- "Test: A1 BC23 DEF456"
lapply(regmatches(s, gregexpr(pattern, s)),
function(e) regmatches(e, regexec(pattern, e)))
lapply(regmatches(s, gregexpr(pattern, s)),
function(e) regmatches(e, regexec(pattern, e)))
library(shiny)
library(miniUI)
library(ggplot2)
ggbrush <- function(data, xvar, yvar) {
ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
runGadget(ui, server)
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot2(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot2(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 2)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
## Plots availability of data and time series for selected variable per IcES rectangle.
## willem.stolte@deltares.nl
iyear = 2003
parameter =
require(mapplots)
dat<-read.table("d:/REPOS-CHECK-OUTS/VECTORS/northsea/PNPP_ICES_data/AllNuts2003-2008.csv",
header=T,sep=",")
#str(dat)  ## Look what's inside
dat<-dat[with(dat, order(year, month)), ]
dat<-subset(dat,dat$year==iyear)
dat<-subset(dat,dat$mindepth == 30)  # choose depth class
col <- terrain.colors(12)  ## add color per month for plotting
dat$color <- col[match(dat$month,1:12)] #dit werkt niet, moet kleuren toekennen per maand...
### Plot ===========================================================
library(rworldmap)
data(countriesLow)
xxlim <- c(0,5)   ## selected range
yylim <- c(50,56)
basemap(xxlim, yylim, main = "data ICES oceanographic database")
plot(countriesLow, add = T, col = "darkolivegreen2")
draw.rect(lty=1, col="darkgrey")
draw.xy(dat$x, dat$y, dat$month, dat$count_temperature, width=1, height=0.5, col= dat$color,  #dat$color,
type="h",lwd=3, border=NA)
draw.xy(dat$x, dat$y, dat$month, dat$avg_temperature, width=1, height=0.5, col="red",
type="l", border=NA,cex=1)
## legend, does not work yet.
#  legend("topleft", c(dat,"month"), pch=c(rep(22,12),16), pt.bg=c(col,NA),
#         pt.cex=c(rep(2,12),0.8),col=c(rep(1,12),2), lty=c(rep(NA,12),1), bg="lightblue",
#         inset=0.02, title="months", cex=0.8)
basemap(xxlim, yylim, main = "data ICES oceanographic database")
plot(countriesLow, add = T, col = "darkolivegreen2")
draw.rect(lty=1, col="darkgrey")
draw.xy(dat$x, dat$y, dat$month, dat$count_temperature, width=1, height=0.5, col= dat$color,  #dat$color,
type="h",lwd=3, border=NA)
draw.xy(dat$x, dat$y, dat$month, dat$avg_temperature, width=1, height=0.5, col="red",
type="l", border=NA,cex=1)
source('D:/GitHubClones/DelwaqR/R/io.R', echo=TRUE)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
library(DelwaqR)
his2arr<- function (filename, timestamp = T, begintime = "1900-01-01 00:00:00")
{
require("stringr")
if (substr(filename, nchar(filename) - 3, nchar(filename)) !=
".his") {
stop("filename does not seem to be a <.his> file")
}
zz <- file(filename, "rb")
readChar(zz, 40)
readChar(zz, 40)
readChar(zz, 40)
readChar(zz, 4)
timeorigin <- readChar(zz, 19)
readChar(zz, 7)
scu.prep <- readChar(zz, 8)
scu  <- as.numeric(scu.prep) # check for the internal timer
sign.scu <- sign(scu)  # sign can be +1, 0 or -1
dec.sign.scu <- ifelse(sign.scu == "-1", "/",
ifelse(sign.scu == "1", "*", stop("The sign of your internal timer is neither negative nor positive, but 0.")))
scu.sym  <- readChar(zz, 1)
readChar(zz, 1)
afm <- readBin(zz, integer(), n = 2)
syname <- vector("character", afm[1])
idump <- vector("integer", afm[2])
duname <- vector("integer", afm[2])
for (i in 1:afm[1]) {
syname[i] <- readChar(zz, 20)
}
for (i in 1:afm[2]) {
idump[i] <- readBin(zz, integer(), n = 1)
duname[i] <- readChar(zz, 20)
}
loc <- seek(zz)
it <- -1
itn <- vector("integer", 0)
tel <- 0
while (length(it) > 0) {
tel <- tel + 1
it <- readBin(zz, integer(), n = 1)
if (length(it) > 0) {
itn <- c(itn, it)
conc <- readBin(zz, "double", n = afm[1] * afm[2],
size = 4)
length(conc)
}
}
seek(zz, where = loc)
concar <- array(dim = c(length(itn), afm[2], afm[1]))
for (i in 1:length(itn)) {
it <- readBin(zz, integer(), n = 1)
concar[i, , ] <- matrix(readBin(zz, "double", n = afm[1] *
afm[2], size = 4), nrow = afm[2], ncol = afm[1],
byrow = T)
}
close(zz)
timeorigin <- str_replace_all(timeorigin, "[.]", "-")
ifelse(timestamp, itn2 <- as.character(as.POSIXct(x = sapply(itn, function(x) as.numeric(eval(parse(text = paste(x, dec.sign.scu, scu))))),
origin = timeorigin, tz = "GMT")), itn2 <- as.character(as.POSIXct(x = sapply(itn, function(x) as.numeric(eval(parse(text = paste(x, dec.sign.scu, scu))))),
origin = begintime, tz = "GMT")))
dimnames(concar) <- list(itn2, str_trim(duname), str_trim(syname))
return(concar)
}
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
library(DelwaqR)
install_github("wstolte/DelwaqR")
library(devtools)
install_github("wstolte/DelwaqR")
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
View(arr2df)
View(arr2df)
View(arr2df)
View(his2arr)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = T, begintime = "2003-01-01 00:00:00")
?parse
source('D:/GitHubClones/DelwaqR/R/io.R', echo=TRUE)
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
plot +
geom_line(aes(), size = 1) +
geom_point(aes(), fill = "white",  shape = 21, size = 4) +
facet_grid((variable ~ location)) +
theme_bw() +
theme(text = element_text(size = 14),
axis.text.x = element_text(angle=90, vjust=0.5))
source('D:/GitHubClones/DelwaqR/R/io.R', echo=TRUE)
arr <- his2arr.2(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
plot +
geom_line(aes(), size = 1) +
geom_point(aes(), fill = "white",  shape = 21, size = 4) +
facet_grid((variable ~ location)) +
theme_bw() +
theme(text = element_text(size = 14),
axis.text.x = element_text(angle=90, vjust=0.5))
library(devtools)
install_github("wstolte/DelwaqR")
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
library(devtools)
install_github("wstolte/DelwaqR")
library(DelwaqR)
install_github("wstolte/DelwaqR")
install_github("wstolte/DelwaqR", dependencies=TRUE)
require(devtools)
install_github("wstolte/DelwaqR")
install_github("wstolte/DelwaqR")
