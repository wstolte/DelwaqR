z =  z + theme(text = element_text(size = 16))
z =  z + scale_x_datetime(breaks = date_breaks("2 months"),  minor_breaks = date_breaks("month"), labels = date_format("%b"))
z =  z + scale_y_continuous(expand = c(0.15,0), breaks = pretty_breaks(n=2)(yy))
#                        labels = comma_format(digits = 1)) +
z =  z + scale_size_continuous(range=c(0,4))
z =  z +geom_text( aes(x = ann.pos.xs, y = steps, label = lablim), data = df.ann, size = 3) # gaat fout soms
z =  z + theme_bw(base_size = 12, base_family = "")
z =  z + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))
z
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
plot +
geom_line(aes(), size = 1) +
geom_point(aes(), fill = "white",  shape = 21, size = 4) +
facet_grid((variable ~ location)) +
theme_bw() +
theme(text = element_text(size = 14),
axis.text.x = element_text(angle=90, vjust=0.5))
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
plot +
geom_line(aes(), size = 1) +
geom_point(aes(), fill = "white",  shape = 21, size = 4) +
facet_grid((variable ~ location)) +
theme_bw() +
theme(text = element_text(size = 14),
axis.text.x = element_text(angle=90, vjust=0.5))
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
library(devtools)
install_github("wstolte/DelwaqR")
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
library(RCurl)
library(XML)
# Download page using RCurl
# You may need to set proxy details, etc.,  in the call to getURL
theurl <- "http://en.wikipedia.org/wiki/Brazil_national_football_team"
webpage <- getURL(theurl)
# Process escape characters
webpage <- readLines(tc <- textConnection(webpage)); close(tc)
# Parse the html tree, ignoring errors on the page
pagetree <- htmlTreeParse(webpage, error=function(...){})
webpage <- getURL(theurl, httpheader = c('User-Agent' = "Willem Stolte, willem.stolte@deltares.nl"))
# Process escape characters
webpage <- readLines(tc <- textConnection(webpage)); close(tc)
# Parse the html tree, ignoring errors on the page
pagetree <- htmlTreeParse(webpage, error=function(...){})
library(XML)
theurl <- "http://en.wikipedia.org/wiki/Brazil_national_football_team"
webpage <- getURL(theurl, httpheader = c('User-Agent' = "Willem Stolte, willem.stolte@deltares.nl"))
# Process escape characters
webpage <- readLines(tc <- textConnection(webpage)); close(tc)
# Parse the html tree, ignoring errors on the page
pagetree <- htmlTreeParse(webpage, error=function(...){})
library(RCurl)
library(XML)
theurl <- "http://en.wikipedia.org/wiki/Brazil_national_football_team"
webpage <- getURL(theurl)
webpage <- readLines(tc <- textConnection(webpage)); close(tc)
pagetree <- htmlTreeParse(webpage, error=function(...){}, useInternalNodes = TRUE)
theurl <- "https://en.wikipedia.org/wiki/Brazil_national_football_team"
webpage <- getURL(theurl)
webpage <- readLines(tc <- textConnection(webpage)); close(tc)
pagetree <- htmlTreeParse(webpage, error=function(...){}, useInternalNodes = TRUE)
theurl <- "https://en.wikipedia.org/wiki/Brazil_national_football_team"
webpage <- getURL(theurl, httpheader = c('User-Agent' = "Willem Stolte, willem.stolte@deltares.nl"))
# Process escape characters
webpage <- readLines(tc <- textConnection(webpage)); close(tc)
# Parse the html tree, ignoring errors on the page
pagetree <- htmlTreeParse(webpage, error=function(...){})
# Navigate your way through the tree. It may be possible to do this more efficiently using getNodeSet
body <- pagetree$children$html$children$body
divbodyContent <- body$children$div$children[[1]]$children$div$children[[4]]
tables <- divbodyContent$children[names(divbodyContent)=="table"]
#In this case, the required table is the only one with class "wikitable sortable"
tableclasses <- sapply(tables, function(x) x$attributes["class"])
thetable  <- tables[which(tableclasses=="wikitable sortable")]$table
#Get columns headers
headers <- thetable$children[[1]]$children
columnnames <- unname(sapply(headers, function(x) x$children$text$value))
# Get rows from table
content <- c()
for(i in 2:length(thetable$children))
{
tablerow <- thetable$children[[i]]$children
opponent <- tablerow[[1]]$children[[2]]$children$text$value
others <- unname(sapply(tablerow[-1], function(x) x$children$text$value))
content <- rbind(content, c(opponent, others))
}
colnames(content) <- columnnames
as.data.frame(content)
require(grid)
demo(grid)
demo()
demo("grid")
demo("grid::")
demo("grid::demo")
grid::demo
grid::demo()
?pushViewport
library(DelwaqR)
library(shiny)
library(miniUI)
library(ggplot2)
ggbrush <- function(data, xvar, yvar) {
ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
library(shiny)
library(miniUI)
library(ggplot2)
ggbrush <- function(data, xvar, yvar) {
ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
runGadget(ui, server)
library(shiny)
library(miniUI)
library(ggplot2)
install.packages(miniUI)
install.packages("miniUI")
install.packages("miniUI")
library(shiny)
library(miniUI)
library(ggplot2)
ggbrush <- function(data, xvar, yvar) {
ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
ggbrush
ggbrush()
ggbrush(mtcars, "hp", "mpg")
ggbrush(mtcars, "hp", "mpg")
x <- c(as = "asfef", qu = "qwerty", "yuiop[", "b", "stuff.blah.yech")
# split x on the letter e
strsplit(x, "e")
strReverse <- function(x)
sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
strReverse(c("abc", "Statistics"))
installed.packages("splitstackshape")
require(splitstackshape)
install.packages(c("curl", "devtools", "ggmap", "httr", "knitr", "maptools", "memoise", "mvtnorm", "ncdf4", "nlme", "R6", "RcppEigen", "RNeo4j", "rstudioapi", "TH.data", "tidyr"))
install.packages("mgcv", lib="D:/stolte/Documents/R/R-3.2.2/library")
install.packages("splitstackshape")
require(splitstackshape)
temp <- head(concat.test)
## Split the "Likes" column
cSplit(temp, "Likes")
temp <- head(concat.test)
View(temp)
cSplit(temp, "Likes")
cSplit(temp, c("Likes", "Hates"), c(",", ";"))
cSplit(temp, "Siblings", ",", direction = "long")
## Split "Siblings" into a long form, removing extra whitespace
cSplit(temp, "Siblings", ",", direction = "long", stripWhite = TRUE)
## Split a vector
y <- c("a_b_c", "a_b", "c_a_b")
cSplit(as.data.table(y), "y", "_")
y
require(stringr)
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
plot +
geom_line(aes(), size = 1) +
geom_point(aes(), fill = "white",  shape = 21, size = 4) +
facet_grid((variable ~ location)) +
theme_bw() +
theme(text = element_text(size = 14),
axis.text.x = element_text(angle=90, vjust=0.5))
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
dimnames(arr)
install.packages("stingi")
install.packages("stringi")
install.packages("stringi")
require(stringi)
stri_split_fixed("a_b_c_d", "_")
stri_split_fixed("a_b_c__d", "_")
stri_split_fixed("a_b_c__d", "_", omit_empty=TRUE)
stri_split_fixed("a_b_c__d", "_", n=2, tokens_only=FALSE) # "a" & remainder
stri_split_fixed("a_b_c__d", "_", n=2, tokens_only=TRUE) # "a" & "b" only
stri_split_fixed("a_b_c__d", "_", n=4, omit_empty=TRUE, tokens_only=TRUE)
stri_split_fixed("a_b_c__d", "_", n=4, omit_empty=FALSE, tokens_only=TRUE)
stri_split_fixed("a_b_c__d", "_", omit_empty=NA)
stri_split_fixed(c("ab_c", "d_ef_g", "h", ""), "_", n=1, tokens_only=TRUE, omit_empty=TRUE)
stri_split_fixed(c("ab_c", "d_ef_g", "h", ""), "_", n=2, tokens_only=TRUE, omit_empty=TRUE)
stri_split_fixed(c("ab_c", "d_ef_g", "h", ""), "_", n=3, tokens_only=TRUE, omit_empty=TRUE)
stri_list2matrix(stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=TRUE))
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=FALSE, simplify=TRUE)
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=NA, simplify=TRUE)
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=TRUE, simplify=TRUE)
stri_split_fixed(c("ab,c", "d,ef,g", ",h", ""), ",", omit_empty=NA, simplify=NA)
test <- "The\u00a0above-mentioned features are very useful. " %s+%
"Warm thanks to their developers. 123 456 789"
stri_split_boundaries(test, type="line")
stri_split_boundaries(test, type="word")
stri_split_boundaries(test, type="word", skip_word_none=TRUE)
stri_split_boundaries(test, type="word", skip_word_none=TRUE, skip_word_letter=TRUE)
stri_split_boundaries(test, type="word", skip_word_none=TRUE, skip_word_number=TRUE)
stri_split_boundaries(test, type="sentence")
stri_split_boundaries(test, type="sentence", skip_sentence_sep=TRUE)
stri_split_boundaries(test, type="sentence")
stri_split_boundaries(test, type="character")
stri_startswith_charclass(" trim me! ", "\\p{WSpace}")
stri_startswith_fixed(c("a1", "a2", "b3", "a4", "c5"), "a")
stri_detect_regex(c("a1", "a2", "b3", "a4", "c5"), "^a")
stri_startswith_fixed("ababa", "ba")
stri_startswith_fixed("ababa", "ba", from=2)
stri_startswith_coll(c("a1", "A2", "b3", "A4", "C5"), "a", strength=1)
pat <- stri_paste("\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 ",
"\u0639\u0644\u064a\u0647 \u0648\u0633\u0644\u0645XYZ")
stri_endswith_coll("\ufdfa\ufdfa\ufdfaXYZ", pat, strength=1)
stri_trim_left(" aaa")
stri_trim_right("rexamine.com/", "\\p{P}")
stri_trim_both(" Total of 23.5 bitcoins. ", "\\p{N}")
stri_trim_both(" Total of 23.5 bitcoins. ", "\\p{L}")
stri_trim_both(" Total of 23.5 bitcoins. ", "\\p{N}")
stri_trim_both("NO301", "\\p{N}")
stri_replace_all_charclass("aaaa", "[a]", "b", merge=c(TRUE, FALSE))
stri_replace_all_charclass("aaaa", "[a]", "b", merge=c(TRUE, FALSE))
stri_replace_all_charclass("a\nb\tc d", "\\p{WHITE_SPACE}", " ")
stri_replace_all_charclass("a\nb\tc d", "\\p{WHITE_SPACE}", " ", merge=TRUE)
s <- "Lorem ipsum dolor sit amet, consectetur adipisicing elit."
stri_replace_all_fixed(s, " ", "#")
stri_replace_all_fixed(s, "o", "0")
stri_replace_all_regex(s, " .*? ", "#")
stri_replace_all_regex('123|456|789', '(\\p{N}).(\\p{N})', '$2-$1')
df$variable
stri_replace_all_regex(s, "(el|s)it", "1234")
stri_replace_all_regex('123|456|789', '(\\p{N}).(\\p{N})', '$2-$1')
grep("[a-z]", letters)
"[a-z]"
grep("[a-z]")
letters
grep("[a-z]", letters)
txt <- c("arm","foot","lefroo", "bafoobar")
if(length(i <- grep("foo", txt)))
cat("'foo' appears at least once in\n\t", txt, "\n")
i # 2 and 4
txt[i]
## Double all 'a' or 'b's;  "\" must be escaped, i.e., 'doubled'
gsub("([ab])", "\\1_\\1_", "abc and ABC")
txt <- c("The", "licenses", "for", "most", "software", "are",
"designed", "to", "take", "away", "your", "freedom",
"to", "share", "and", "change", "it.",
"", "By", "contrast,", "the", "GNU", "General", "Public", "License",
"is", "intended", "to", "guarantee", "your", "freedom", "to",
"share", "and", "change", "free", "software", "--",
"to", "make", "sure", "the", "software", "is",
"free", "for", "all", "its", "users")
( i <- grep("[gu]", txt) ) # indices
stopifnot( txt[i] == grep("[gu]", txt, value = TRUE) )
(ot <- sub("[b-e]",".", txt))
txt[ot != gsub("[b-e]",".", txt)]#- gsub does "global" substitution
txt[gsub("g","#", txt) !=
gsub("g","#", txt, ignore.case = TRUE)] # the "G" words
regexpr("en", txt)
gregexpr("e", txt)
## Using grepl() for filtering
## Find functions with argument names matching "warn":
findArgs <- function(env, pattern) {
nms <- ls(envir = as.environment(env))
nms <- nms[is.na(match(nms, c("F","T")))] # <-- work around "checking hack"
aa <- sapply(nms, function(.) { o <- get(.)
if(is.function(o)) names(formals(o)) })
iw <- sapply(aa, function(a) any(grepl(pattern, a, ignore.case=TRUE)))
aa[iw]
}
findArgs("package:base", "warn")
str <- "Now is the time      "
sub(" +$", "", str)  ## spaces only
## what is considered 'white space' depends on the locale.
sub("[[:space:]]+$", "", str) ## white space, POSIX-style
## what PCRE considered white space changed in version 8.34: see ?regex
sub("\\s+$", "", str, perl = TRUE) ## PCRE-style white space
## capitalizing
txt <- "a test of capitalizing"
gsub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)
gsub("\\b(\\w)",    "\\U\\1",       txt, perl=TRUE)
txt2 <- "useRs may fly into JFK or laGuardia"
gsub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
sub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
## named capture
notables <- c("  Ben Franklin and Jefferson Davis",
"\tMillard Fillmore")
# name groups 'first' and 'last'
name.rex <- "(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)"
(parsed <- regexpr(name.rex, notables, perl = TRUE))
gregexpr(name.rex, notables, perl = TRUE)[[2]]
parse.one <- function(res, result) {
m <- do.call(rbind, lapply(seq_along(res), function(i) {
if(result[i] == -1) return("")
st <- attr(result, "capture.start")[i, ]
substring(res[i], st, st + attr(result, "capture.length")[i, ] - 1)
}))
colnames(m) <- attr(result, "capture.names")
m
}
parse.one(notables, parsed)
## Decompose a URL into its components.
## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
x <- "http://stat.umn.edu:80/xyz"
m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
m
regmatches(x, m)
## Element 3 is the protocol, 4 is the host, 6 is the port, and 7
## is the path.  We can use this to make a function for extracting the
## parts of a URL:
URL_parts <- function(x) {
m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
parts <- do.call(rbind,
lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)))
colnames(parts) <- c("protocol","host","port","path")
parts
}
URL_parts(x)
## There is no gregexec() yet, but one can emulate it by running
## regexec() on the regmatches obtained via gregexpr().  E.g.:
pattern <- "([[:alpha:]]+)([[:digit:]]+)"
s <- "Test: A1 BC23 DEF456"
lapply(regmatches(s, gregexpr(pattern, s)),
function(e) regmatches(e, regexec(pattern, e)))
lapply(regmatches(s, gregexpr(pattern, s)),
function(e) regmatches(e, regexec(pattern, e)))
library(shiny)
library(miniUI)
library(ggplot2)
ggbrush <- function(data, xvar, yvar) {
ui <- miniPage(
gadgetTitleBar("Drag to select points"),
miniContentPanel(
# The brush="brush" argument means we can listen for
# brush events on the plot using input$brush.
plotOutput("plot", height = "100%", brush = "brush")
)
)
server <- function(input, output, session) {
# Render the plot
output$plot <- renderPlot({
# Plot the data with x/y vars indicated by the caller.
ggplot(data, aes_string(xvar, yvar)) + geom_point()
})
# Handle the Done button being pressed.
observeEvent(input$done, {
# Return the brushed points. See ?shiny::brushedPoints.
stopApp(brushedPoints(data, input$brush))
})
}
runGadget(ui, server)
}
runGadget(ui, server)
library(DelwaqR)
arr <- his2arr(filename = "DATA/NZBLOOM.his", timestamp = F, begintime = "2003-01-01 00:00:00")
dimnames(arr)
submod <- c("Chlfa", "OXY")
locmod <- c("NZR6NW020", "NZR9TS010")
df <- arr2df(arr, locmod=locmod, submod=submod)
df$value[df$variable == "fResptot"] <- -df$value[df$variable == "fResptot"]
library(ggplot2)
plot <- ggplot(df, aes(time, value))
plot +
geom_line(aes(color = variable), size = 1) +
geom_point(aes(color = variable), fill = "white",  shape = 21, size = 4) +
facet_grid((. ~ location))
limmod = c("Limit e", "Limit nit", "Limit pho", "Limit sil")
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot2(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot2(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 2)
DelwaqEcoplot(arr = arr, locmod = locmod, submod = submod, limmod = limmod, plottype = 1)
## Plots availability of data and time series for selected variable per IcES rectangle.
## willem.stolte@deltares.nl
iyear = 2003
parameter =
require(mapplots)
dat<-read.table("d:/REPOS-CHECK-OUTS/VECTORS/northsea/PNPP_ICES_data/AllNuts2003-2008.csv",
header=T,sep=",")
#str(dat)  ## Look what's inside
dat<-dat[with(dat, order(year, month)), ]
dat<-subset(dat,dat$year==iyear)
dat<-subset(dat,dat$mindepth == 30)  # choose depth class
col <- terrain.colors(12)  ## add color per month for plotting
dat$color <- col[match(dat$month,1:12)] #dit werkt niet, moet kleuren toekennen per maand...
### Plot ===========================================================
library(rworldmap)
data(countriesLow)
xxlim <- c(0,5)   ## selected range
yylim <- c(50,56)
basemap(xxlim, yylim, main = "data ICES oceanographic database")
plot(countriesLow, add = T, col = "darkolivegreen2")
draw.rect(lty=1, col="darkgrey")
draw.xy(dat$x, dat$y, dat$month, dat$count_temperature, width=1, height=0.5, col= dat$color,  #dat$color,
type="h",lwd=3, border=NA)
draw.xy(dat$x, dat$y, dat$month, dat$avg_temperature, width=1, height=0.5, col="red",
type="l", border=NA,cex=1)
## legend, does not work yet.
#  legend("topleft", c(dat,"month"), pch=c(rep(22,12),16), pt.bg=c(col,NA),
#         pt.cex=c(rep(2,12),0.8),col=c(rep(1,12),2), lty=c(rep(NA,12),1), bg="lightblue",
#         inset=0.02, title="months", cex=0.8)
basemap(xxlim, yylim, main = "data ICES oceanographic database")
plot(countriesLow, add = T, col = "darkolivegreen2")
draw.rect(lty=1, col="darkgrey")
draw.xy(dat$x, dat$y, dat$month, dat$count_temperature, width=1, height=0.5, col= dat$color,  #dat$color,
type="h",lwd=3, border=NA)
draw.xy(dat$x, dat$y, dat$month, dat$avg_temperature, width=1, height=0.5, col="red",
type="l", border=NA,cex=1)
